## Odd or Not

        /* 
        much faster than num % 2
        and also more accurate ... handles negative numbers 
        */

        public boolean oddOrNot(int num) {  
            return (num & 1) != 0;  
        }

------

## System.currentTimeMillis() and System.nanoTime() 

The question is, which of these to choose and under what circumstances. In principle, they both perform the same action but are different in the following ways:

* System.currentTimeMillis takes somewhere between 1/1000th of a second to 15/1000th of a second (depending on the system) but System.nanoTime() takes around 1/1000,000th of a second (1,000 nanos)
* System.currentTimeMillis takes a few clock cycles to perform Read Operation. On the other hand, System.nanoTime() takes 100+ clock cycles.
* System.currentTimeMillis reflects Absolute Time (Number of millis since 1 Jan 1970 00:00 (Epoch Time)) but System.nanoTime() does not necessarily represent any reference point.

------

## Prefer Double over Float. 

Provides far more precision and both take about the same computation time.

------

## 10-50-500 Rule

In big software packages, maintaining code becomes very challenging. Developers who join fresh ongoing support projects, often complain about: Monolithic Code, Spaghetti Code. There is a very simple rule to avoid that or keep the code clean and maintainable: 10-50-500.

* 10: No package can have more than 10 classes.
* 50: No method can have more than 50 lines of code.
* 500: No class can have more than 500 lines of code.
    
------

## Avoid Floating Point Numbers

Floating point numbers should be used only if they are absolutely necessary. For example, representing Rupees and Paise using Floating Point numbers can be Problematic â€“ BigDecimal should instead be preferred. Floating point numbers are more useful in measurement

------

