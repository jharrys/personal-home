## Terms

image == the specification of the guest; the Dockerfile basically  
container == an image that has been started; it’s running image 

## Examples

* View logs of a running container

        > docker logs <container-id>

* Detach from connected container shell without killing running instance (only works if container was initiated "run -t -i" -t=tty -i=interactive)

        > Ctrl+p + Ctrl+q
        
* Attach to a shell to interact

        > start the container (docker run -i -t <container-name>)
        --- later on ---
        > docker exec -i -t <container-name> /bin/bash

* Other way to attach (doesn't always provide a shell to interact with)

        > docker attach <container-name>

## Cheat sheet

        docker help <command>           # get help for command
        docker container                        # manage containers
        docker container ls                     # list all containers
        docker attach <containerID>      # attach to a running container
        docker ps                                 # See a list of all *running* containers
        docker ps -a                               # list all containers whether running or not
        docker run -it                  # same as -i -t ; allocates a tty
        docker stop <hash>                     # Gracefully stop the specified container
        docker kill <hash>                   # Force shutdown of the specified container
        docker rm <hash>              # Remove the specified container from this machine
        docker rm $(docker ps -a -q)           # Remove all containers from this machine
        docker images -a                               # Show all images on this machine
        docker rmi <imagename>            # Remove the specified image from this machine
        docker rmi $(docker images -q)             # Remove all images from this machine
        docker login             # Log in this CLI session using your Docker credentials
        docker build -t friendlyname .  # Create image using this directory's Dockerfile
        docker run -p 4000:80 friendlyname  # Run "friendlyname" mapping port 4000 to 80
        docker run -d -p 4000:80 friendlyname         # Same thing, but in detached mode
        docker tag <image> username/repository:tag  # Tag <image> for upload to registry
        docker push username/repository:tag            # Upload tagged image to registry
        docker run username/repository:tag                   # Run image from a registry


## Example of how to run docker for development with source code in your current directory $(pwd)

        docker run --rm -v "$(pwd)":/app -w /app iron/ruby:2.2 sh -c 'ruby hello.rb'
        
        --rm : clean up after container is done running
        -v: map the current directory $(pwd) on the host to /app on the container
        -w: make /app on the container the working directory
        [image]: iron/ruby:2.2 is the image to run with tag 2.2
        [command]: sh -c ‘ruby hello.rb’ hello.rb would be found in the /app directory mapped to your pwd
        
See [this](https://medium.com/travis-on-docker/why-and-how-to-use-docker-for-development-a156c1de3b24) for more examples.
        
## Sample creating a python app using Docker (nothing installed on host, including Python)

* Create a directory ‘tmp’
* will contain the following

        $ ls
        Dockerfile      app.py      requirements.txt
        
* Dockerfile contains:

        # Use an official Python runtime as a base image
        FROM python:2.7-slim
        
        # Set the working directory to /app
        WORKDIR /app
        
        # Copy the current directory contents into the container at /app
        ADD . /app
        
        # Install any needed packages specified in requirements.txt
        RUN pip install -r requirements.txt
        
        # Make port 80 available to the world outside this container
        EXPOSE 80
        
        # Define environment variable
        ENV NAME World
        
        # Run app.py when the container launches
        CMD ["python", "app.py"]

* requirements.txt contains

        Flask
        Redis

* app.py contains

        from flask import Flask
        from redis import Redis, RedisError
        import os
        import socket
        
        # Connect to Redis
        redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)
        
        app = Flask(__name__)
        
        @app.route("/")
        def hello():
            try:
                visits = redis.incr('counter')
            except RedisError:
                visits = "<i>cannot connect to Redis, counter disabled</i>"
        
            html = "<h3>Hello {name}!</h3>" \
                   "<b>Hostname:</b> {hostname}<br/>" \
                   "<b>Visits:</b> {visits}"
            return html.format(name=os.getenv('NAME', "world"), hostname=socket.gethostname(), visits=visits)
        
        if __name__ == "__main__":
            app.run(host='0.0.0.0', port=80)

* Now to build the docker image with python, flask and redis and your app.py “friendlyhello” is a friendly tag to reference the image by.

    * docker build -t friendlyhello .
    
    
* where is the image (on you local docker image registry)

        $ docker images
        
* run the app, but map the container’s port 80 to the host’s port 4000

        $ docker run -p 4000:80 friendlyhello

* you can access this from your host at ‘http://localhost:4000’; the ps command will show you the container.

        $ docker ps
        
## Registries and Repositories

        // (sign up for an account cloud.docker.com) - my username here is ‘jharrys’  
        docker login 
        
        // tag your image - where tag is something like ‘version1.0’ or ‘1.0’  
        docker tag localname:tag username/repository:tag
        
        // example
        // note here that the name friendlyhello is not followed by a tag, this means it is assumed to be :latest  
        docker tag friendlyhello username/repository:tag
        
        // push your tagged image  
        docker push username/repository:tag
        
        // from anywhere anyone can run your tagged image (not specifying tag docker will assume :latest)  
        docker run -p 4000:80 username/repository:tag
