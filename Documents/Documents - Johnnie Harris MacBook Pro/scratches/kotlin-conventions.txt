# Kotlin stuff I'm learning
---
BY KEYWORD

interface Base {
    val blah: String
    fun printMessage()
    fun printMessageLine()
    fun printBlah()
}
class BaseImpl(val x: Int) : Base {
    override val blah = "BaseImpl: x = $x"
    override fun printMessage() { print(x) }
    override fun printMessageLine() { println(x) }
    override fun printBlah() { println(blah) }
}
class Derived(b: Base) : Base by b {
    override val blah = "Derived Message"
    override fun printMessage() { print("abc") }
}
fun main(args: Array<String>) {
    val b = BaseImpl(10)
    Derived(b).printMessage()       //prints "abc"
    Derived(b).printMessageLine()   // prints 10
    Derived(b).printBlah()          // prints "BaseImpl: x = 10" ... Derived blah property can't be accessed from b's implementation
}

BY with properties
class Example {
    var p: String by Delegate()
}
class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}
val e = Example()
println(e.p) // Example@33a17727, thank you for delegating ‘p’ to me!
e.p = "NEW" // NEW has been assigned to ‘p’ in Example@33a17727.

---
PROPERTIES
val isEmpty: Boolean get() = size == 0 //simplest formatting
val foo: String
    get() { ... }
    set() { ... }

---
CHECKS AND CASTS (SMART CASTS): kotlin remembers the use of "is" and will smart cast the next use of the object based on "is" calculation
if (obj is String) {
    print(obj.length)
}
if (obj !is String) { // same as !(obj is String)
    print("Not a String")
}
else {
    print(obj.length)
}

Smart Cast
if (x !is String) return
    print(x.length) // x is automatically cast to String

Smart Cast great for when loops:
when (x) {
    is Int -> print(x + 1)
    is String -> print(x.length + 1)
    is IntArray -> print(x.sum())
}

---
CAST OPERATOR
"as" - but it's not null safe
"as?" - is null safe
val x: String? = y as? String

---
STRING TEMPLATES
println("$name has ${children.size} children")

---
FUNCTION FORMATTING
fun foo(): Int {     // bad
    return 1
}

fun foo() = 1        // good

---
UNIT: real type
1. for functions that don't return anything
2. from category theory meaning contains exactly 1
3. corresponds to Java's void, but as a real type and a singleton
4. optional, doesn't have to be declared
5. you can actually 'return Unit' or 'return' but either is optional

---
NOTHING: real type
1. for functions that never return (i.e, throws exception or infinite loop)
2. when called from a function that returns a real type, you can call the function after a return and the compiler will still compile
fun foo(): Nothing {
    throw RuntimeException()
}
fun doSomething(): String {
    if(n>5)
        return "greater than 5"

    foo() // in java would error with "no return", kotlin is just fine
}

---
TYPE ALIASES
typealias NodeSet = Set<Network.Node>

typealias FileTable<K> = MutableMap<K, MutableList<File>>

---
VARARGS keyword
fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}
---
@FILE:JVMNAME("USERUTILS")
1. placed before package but after initial comment (licensing info)
2. tells compiler to generate the class name as "UserUtils", instead of the one named

{} when invoking function
1. if the last parameter is a lambda, kotlin lets you call it after parenthesis as {}
List.last() accepts a lambda as a parameter
val stringList: List<String> = listOf("in", "the", "club")
stringList.last { s -> s.length == 3 } OR stringList.last { it.length == 3 }

---
LABELS
fun surroundingFunction() {
    val intList = listOf(1, 2, 3, 4, 5)
    intList.forEach {
        if (it % 2 == 0) {
            return
        }
    }
    println("End of surroundingFunction()")
}

surroundingFunction() // nothing happened because the return statement returns the whole function

instead modify return with "return@forEach", it will return to the "implied label" with the forEach.
OR
you can create your own explicit label: "intList.forEach myLabel@ {", then use "return@myLabel"
== ** labels work not just for loops, almost anything ** ==

---
define COMPONENT OBJECT at end of function

---
ANONYMOUS FUNCTION

normal way:
val stringList: List<String> = listOf("in", "the", "club")
print(stringList.last{ it.length == 3}) // will print "the"

anonymous way: (not, uses the keyword fun, has no name to it, and contains a fun body)
val strLenThree = stringList.last( fun(string): Boolean {
    return string.length == 3
})
print(strLenThree) // will print "the"

---
INLINE keyword: although the fun is declared separately, compiler inlines it where used, optimizing it to run faster ... however it makes the code longer

---
INFIX keyword: for single arg functions, allows us to make the calling of the fun very expressive
* the actual use of the infix function has 3 items: receiver fun param
class Student {
    var kotlinScore = 0.0

    infix fun addKotlinScore(score: Double): Unit {
        this.kotlinScore = kotlinScore + score
    }

    infix fun isBetterThan(score: Double): Boolean {
        return this.kotlinScore > score
    }
}

val student = Student()
student addKotlinScore 95.00 // <---- MUCH MORE EXPRESSIVE WAY TO CALL .... receiver=student, fun=addKotlinScore
student isBetterThan 70.00 // better example
print(student.kotlinScore) // will print "95.0"

***
the "to" infix function
public infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)

val nigeriaCallingCodePair = 234 to "Nigeria"
val nigeriaCallingCodePair2 = Pair(234, "Nigeria") // Same as above

ALSO
val nigeriaCallingCodePair3 = 234.to("Nigeria") // same as using 234 to "Nigeria"
val callingCodesMap: Map<Int, String> = mapOf(234 to "Nigeria", 1 to "USA", 233 to "Ghana")
val callingCodesPairMap: Map<Int, String> = mapOf(Pair(234, "Nigeria"), Pair(1, "USA"), Pair(233, "Ghana"))

---
TAIL RECURSION
val eps = 1E-10 // "good enough", could be 10^-15

tailrec fun findFixPoint(x: Double = 1.0): Double
        = if (Math.abs(x - Math.cos(x)) < eps) x else findFixPoint(Math.cos(x))

---
